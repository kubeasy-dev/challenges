apiVersion: v1
kind: ConfigMap
metadata:
  name: check-secret-configuration
data:
  secret-env-vars.rego: |
    package kubeasy.challenge

    violation[{"msg": msg}] {
      container := input.spec.template.spec.containers[_]
      env := container.env[_]
      env.name == "DATABASE_HOST"
      env.value == "wrong-host.example.com"
      msg := "DATABASE_HOST should be sourced from the Secret, not hardcoded"
    }

    violation[{"msg": msg}] {
      container := input.spec.template.spec.containers[_]
      not has_env_from_secret(container, "DATABASE_USER")
      msg := "DATABASE_USER must be defined and sourced from 'database-credentials' Secret"
    }

    violation[{"msg": msg}] {
      container := input.spec.template.spec.containers[_]
      not has_env_from_secret(container, "DATABASE_PASSWORD")
      msg := "DATABASE_PASSWORD must be defined and sourced from 'database-credentials' Secret"
    }

    violation[{"msg": msg}] {
      container := input.spec.template.spec.containers[_]
      has_env_key(container, "DATABASE_HOST")
      not has_env_from_secret(container, "DATABASE_HOST")
      msg := "DATABASE_HOST must be sourced from 'database-credentials' Secret"
    }

    has_env_key(container, key) {
      container.env[_].name == key
    }

    has_env_from_secret(container, key) {
      env := container.env[_]
      env.name == key
      env.valueFrom.secretKeyRef.name == "database-credentials"
      env.valueFrom.secretKeyRef.key == key
    }

  secret-reference.rego: |
    package kubeasy.challenge

    violation[{"msg": msg}] {
      container := input.spec.template.spec.containers[_]
      count([e | e := container.env[_]; e.valueFrom.secretKeyRef.name == "database-credentials"]) == 0
      msg := "Deployment must reference the 'database-credentials' Secret for at least one environment variable"
    }
